/*
--
This file is automatically generated. Any manual changes to this file may be overwritten.
It includes routes and handlers by the Gleece API Routes Generator.
--
Authors: Haim Kastner & Yuval Pomerchik
Generated by: Gleece Routes Generator
Generated Date: 2025-05-30
Target Engine: Gin (https://github.com/gin-gonic/gin)
--
Usage:
Refer to the Gleece documentation for details on how to use the generated routes and handlers.
--
Repository: https://github.com/gopher-fleece/gleece
--
*/
package routes
import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/textproto"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	RequestAuth "github.com/gopher-fleece/gleecexample/security"
	"github.com/gopher-fleece/runtime"
	Param7domicile "github.com/gopher-fleece/gleecexample/controllers"
	UsersControllerImport "github.com/gopher-fleece/gleecexample/controllers"
	// import extension placeholder
)
var validatorInstance = validator.New()
var urlParamRegex *regexp.Regexp
type SecurityListRelation string
const (
	SecurityListRelationAnd SecurityListRelation = "AND"
)
type SecurityCheckList struct {
	Checks   []runtime.SecurityCheck
	Relation SecurityListRelation
}
// type declarations extension placeholder
func getRequestContext(ginCtx *gin.Context) context.Context {
	return ginCtx.Request.Context()
}
func setRequestContext(ginCtx *gin.Context, ctx context.Context) {
	if ctx != nil {
		ginCtx.Request = ginCtx.Request.WithContext(ctx)
	}
}
func registerEnumValidation(validate *validator.Validate, validationName string, allowedValues []string) {
	// Convert the array to a map for O(1) lookup
	lookup := make(map[string]struct{})
	for _, val := range allowedValues {
		lookup[val] = struct{}{}
	}
	// Register the custom validation
	validate.RegisterValidation(validationName, func(fl validator.FieldLevel) bool {
		field := fl.Field().String()
		_, exists := lookup[field]
		return exists
	})
}
func extractValidationErrorMessage(err error, fieldName *string) string {
	if err == nil {
		return ""
	}
	validationErrors, ok := err.(validator.ValidationErrors)
	if !ok {
		return err.Error()
	}
	var errStr string
	for _, validationErr := range validationErrors {
		fName := validationErr.Field()
		if fieldName != nil {
			fName = *fieldName
		}
		errStr += fmt.Sprintf("Field '%s' failed validation with tag '%s'. ", fName, validationErr.Tag())
	}
	return errStr
}
func getStatusCode(controller runtime.Controller, hasReturnValue bool, err error) int {
	if controller.GetStatus() != nil {
		return int(*controller.GetStatus())
	}
	if err != nil {
		return http.StatusInternalServerError
	}
	if hasReturnValue {
		return http.StatusOK
	}
	return http.StatusNoContent
}
func bindAndValidateBody[TOutput any](ginCtx *gin.Context, contentType string, validation string, output **TOutput) error {
	var err error
	bodyBytes, err := io.ReadAll(ginCtx.Request.Body)
	if err != nil || len(bodyBytes) == 0 {
		if strings.Contains(validation, "required") {
			return fmt.Errorf("body is required but was not provided")
		}
		return nil
	}
	var deserializedOutput TOutput
	switch contentType {
	case "application/json":
		err = json.Unmarshal(bodyBytes, &deserializedOutput)
	default:
		return fmt.Errorf("content-type %s is not currently supported by the validation subsystem", contentType)
	}
	if err != nil {
		return err
	}
	// Validate the unmarshaled data recursively
	if err = validateDataRecursive(deserializedOutput, ""); err != nil {
		return err
	}
	*output = &deserializedOutput
	return nil
}
func validateDataRecursive(data interface{}, path string) error {
	val := reflect.ValueOf(data)
	// Handle pointers by dereferencing
	if val.Kind() == reflect.Ptr {
		if val.IsNil() {
			return nil
		}
		return validateDataRecursive(val.Elem().Interface(), path)
	}
	// Handle different types
	switch val.Kind() {
	case reflect.Slice, reflect.Array:
		// For slices/arrays, validate each element recursively
		for i := 0; i < val.Len(); i++ {
			elemPath := path
			if path != "" {
				elemPath = fmt.Sprintf("%s[%d]", path, i)
			} else {
				elemPath = fmt.Sprintf("[%d]", i)
			}
			// Get the element - handle case where element might be nil
			elem := val.Index(i)
			if elem.Kind() == reflect.Ptr && elem.IsNil() {
				continue
			}
			// Validate the element recursively
			if err := validateDataRecursive(elem.Interface(), elemPath); err != nil {
				return err
			}
		}
		return nil
	case reflect.Map:
		// For maps, validate each value recursively
		for _, key := range val.MapKeys() {
			elemPath := path
			if path != "" {
				elemPath = fmt.Sprintf("%s.%v", path, key.Interface())
			} else {
				elemPath = fmt.Sprintf("%v", key.Interface())
			}
			elemVal := val.MapIndex(key)
			if elemVal.Kind() == reflect.Ptr && elemVal.IsNil() {
				continue
			}
			if err := validateDataRecursive(elemVal.Interface(), elemPath); err != nil {
				return err
			}
		}
		return nil
	case reflect.Struct:
		// Validate structs with the validator
		if err := validatorInstance.Struct(data); err != nil {
			if path != "" {
				return fmt.Errorf("validation error at %s: %w", path, err)
			}
			return err
		}
		return nil
	default:
		// Primitive types don't need validation
		return nil
	}
}
func toGinUrl(url string) string {
	processedUrl := urlParamRegex.ReplaceAllString(url, ":$1")
	processedUrl = strings.ReplaceAll(processedUrl, "//", "/")
	if processedUrl == "" {
		return "/"
	}
	if !strings.HasPrefix(processedUrl, "/") {
		processedUrl = "/" + processedUrl
	}
	return processedUrl
}
func authorize(ginCtx *gin.Context, checksLists []SecurityCheckList) *runtime.SecurityError {
	var lastError *runtime.SecurityError
	for _, list := range checksLists {
		if list.Relation != SecurityListRelationAnd {
			panic(
				"Encountered a security list relation of type '%s' - this is unexpected and indicates a bug in Gleece itself." +
					"Please open an issue at https://github.com/gopher-fleece/gleece/issues",
			)
		}
		// Iterate over each security list
		encounteredErrorInList := false
		for _, check := range list.Checks {
			secCtx, secErr := RequestAuth.GleeceRequestAuthorization(getRequestContext(ginCtx), ginCtx, check)
			setRequestContext(ginCtx, secCtx)
			if secErr != nil {
				lastError = secErr
				encounteredErrorInList = true
				break
			}
		}
		// If no error was encountered, validation is considered successful
		// otherwise, we continue over to the next iteration whilst keeping track of the last error
		if !encounteredErrorInList {
			return nil
		}
	}
	// If we got here it means authentication has failed
	return lastError
}
func handleAuthorizationError(ginCtx *gin.Context, authErr *runtime.SecurityError, operationId string) {
	statusCode := int(authErr.StatusCode)
	if authErr.CustomError != nil {
		// For now, we support JSON only
		ginCtx.JSON(statusCode, authErr.CustomError.Payload)
		return
	}
	stdError := runtime.Rfc7807Error{
		Type:     http.StatusText(statusCode),
		Detail:   authErr.Message,
		Status:   statusCode,
		Instance: "/authorization/error/" + operationId,
	}
	ginCtx.JSON(statusCode, stdError)
}
func wrapValidatorError(validatorErr error, operationId string, fieldName string) runtime.Rfc7807Error {
	return runtime.Rfc7807Error{
		Type: http.StatusText(http.StatusUnprocessableEntity),
		Detail: fmt.Sprintf(
			"A request was made to operation '%s' but parameter '%s' did not pass validation - %s",
			operationId,
			fieldName,
			extractValidationErrorMessage(validatorErr, &fieldName),
		),
		Status:   http.StatusUnprocessableEntity,
		Instance: fmt.Sprintf("/validation/error/%s", operationId),
	}
}
// function declarations extension placeholder
type MiddlewareFunc func(ctx context.Context, ginCtx *gin.Context) (context.Context, bool)
type ErrorMiddlewareFunc func(ctx context.Context, ginCtx *gin.Context, err error) (context.Context, bool)
var beforeOperationMiddlewares []MiddlewareFunc
var afterOperationSuccessMiddlewares []MiddlewareFunc
var onErrorMiddlewares []ErrorMiddlewareFunc
var onInputValidationMiddlewares []ErrorMiddlewareFunc
var onOutputValidationMiddlewares []ErrorMiddlewareFunc
func RegisterMiddleware(executionType runtime.MiddlewareExecutionType, middlewareFunc MiddlewareFunc) {
	switch executionType {
	case runtime.BeforeOperation:
		beforeOperationMiddlewares = append(beforeOperationMiddlewares, middlewareFunc)
	case runtime.AfterOperationSuccess:
		afterOperationSuccessMiddlewares = append(afterOperationSuccessMiddlewares, middlewareFunc)
	}
}
func RegisterErrorMiddleware(executionType runtime.ErrorMiddlewareExecutionType, errorMiddlewareFunc ErrorMiddlewareFunc) {
	switch executionType {
	case runtime.OnInputValidationError:
		onInputValidationMiddlewares = append(onInputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOutputValidationError:
		onOutputValidationMiddlewares = append(onOutputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOperationError:
		onErrorMiddlewares = append(onErrorMiddlewares, errorMiddlewareFunc)
	}
}
func RegisterCustomValidator(validateTagName string, validateFunc runtime.ValidationFunc) {
	validatorInstance.RegisterValidation(validateTagName, func(fl validator.FieldLevel) bool {
		return validateFunc(fl)
	})
}
func RegisterRoutes(engine *gin.Engine) {
	urlParamRegex = regexp.MustCompile(`\{([\w\d-_]+)\}`)
	// register routes extension placeholder
	// UsersController
	engine.POST(toGinUrl("/users/user/{user_name}/{user_id}/{serial}"), func(ginCtx *gin.Context) {
		// route start routes extension placeholder
		authErr := authorize(
			ginCtx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"read:users",
								"write:users",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ginCtx, authErr, "CreateNewUser")
			return
		}
		controller := UsersControllerImport.UsersController{}
		controller.InitController(ginCtx)
		var conversionErr error
		var idRawPtr *int = nil
		idRaw, isidExists := ginCtx.Params.Get("user_id")
		if isidExists {
			idUint64, conversionErr := strconv.Atoi(idRaw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, conversionErr)
					setRequestContext(ginCtx, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'CreateNewUser' but parameter '%s' was not properly sent - Expected %s but got %s",
						"id",
						"int",
						reflect.TypeOf(idRaw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/CreateNewUser",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
				return
			}
			id := int(idUint64)
			idRawPtr = &id
		}
		if validatorErr := validatorInstance.Var(idRawPtr, "gt=1,required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, validatorErr)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "id"
			validationError := wrapValidatorError(validatorErr, "CreateNewUser", fieldName)
			// validation error response extension placeholder
			ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var serialRawPtr *int = nil
		serialRaw, isserialExists := ginCtx.Params.Get("serial")
		if isserialExists {
			serialUint64, conversionErr := strconv.Atoi(serialRaw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, conversionErr)
					setRequestContext(ginCtx, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'CreateNewUser' but parameter '%s' was not properly sent - Expected %s but got %s",
						"serial",
						"int",
						reflect.TypeOf(serialRaw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/CreateNewUser",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
				return
			}
			serial := int(serialUint64)
			serialRawPtr = &serial
		}
		if validatorErr := validatorInstance.Var(serialRawPtr, "gte=10,required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, validatorErr)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "serial"
			validationError := wrapValidatorError(validatorErr, "CreateNewUser", fieldName)
			// validation error response extension placeholder
			ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var emailRawPtr *string = nil
		emailRaw, isemailExists := ginCtx.GetQuery("email")
		if isemailExists {
			email := emailRaw
			emailRawPtr = &email
		}
		if validatorErr := validatorInstance.Var(emailRawPtr, "required,email"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, validatorErr)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "email"
			validationError := wrapValidatorError(validatorErr, "CreateNewUser", fieldName)
			// validation error response extension placeholder
			ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var nameRawPtr *string = nil
		nameRaw, isnameExists := ginCtx.Params.Get("user_name")
		if isnameExists {
			name := nameRaw
			nameRawPtr = &name
		}
		if validatorErr := validatorInstance.Var(nameRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, validatorErr)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "name"
			validationError := wrapValidatorError(validatorErr, "CreateNewUser", fieldName)
			// validation error response extension placeholder
			ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var originRawPtr *string = nil
		originRaw := ginCtx.GetHeader("x-origin")
		_, isoriginExists := ginCtx.Request.Header[textproto.CanonicalMIMEHeaderKey("x-origin")]
		if isoriginExists {
			origin := originRaw
			originRawPtr = &origin
		}
		if validatorErr := validatorInstance.Var(originRawPtr, "validate_starts_with_letter,required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, validatorErr)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "origin"
			validationError := wrapValidatorError(validatorErr, "CreateNewUser", fieldName)
			// validation error response extension placeholder
			ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var optionRawPtr *string = nil
		optionRaw := ginCtx.GetHeader("x-option")
		_, isoptionExists := ginCtx.Request.Header[textproto.CanonicalMIMEHeaderKey("x-option")]
		if isoptionExists {
			option := optionRaw
			optionRawPtr = &option
		}
		var traceRawPtr *string = nil
		traceRaw := ginCtx.GetHeader("trace")
		_, istraceExists := ginCtx.Request.Header[textproto.CanonicalMIMEHeaderKey("trace")]
		if istraceExists {
			trace := traceRaw
			traceRawPtr = &trace
		}
		if validatorErr := validatorInstance.Var(traceRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, validatorErr)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "trace"
			validationError := wrapValidatorError(validatorErr, "CreateNewUser", fieldName)
			// validation error response extension placeholder
			ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var domicileRawPtr *Param7domicile.Domicile = nil
		conversionErr = bindAndValidateBody(ginCtx, "application/json", "required", &domicileRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, conversionErr)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'CreateNewUser' but body parameter '%s' did not pass validation of '%s' - %s",
					"domicile",
					"Domicile",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/CreateNewUser",
			}
			// json body validation error response extension placeholder
			ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx)
			setRequestContext(ginCtx, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.CreateNewUser(*idRawPtr, *serialRawPtr, *emailRawPtr, *nameRawPtr, *originRawPtr, optionRawPtr, *traceRawPtr, *domicileRawPtr)
		for key, value := range controller.GetHeaders() {
			ginCtx.Header(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, opError)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'CreateNewUser'",
				Status:     statusCode,
				Instance:   "/controller/error/CreateNewUser",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			ginCtx.JSON(statusCode, stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx)
			setRequestContext(ginCtx, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		if opError == nil {
			resString := ""
			jsonValue, _ := json.Marshal(value)
			resString = string(jsonValue)
			println("Operation 'CreateNewUser' succeeded, response: ", resString)
		}
		ginCtx.JSON(statusCode, value)
		// route end routes extension placeholder
	})
	engine.GET(toGinUrl("/users/domicile/{id}"), func(ginCtx *gin.Context) {
		// route start routes extension placeholder
		authErr := authorize(
			ginCtx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"read:users",
							},
						},
					},
				},
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"read:all_data",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ginCtx, authErr, "GetUserDomicile")
			return
		}
		controller := UsersControllerImport.UsersController{}
		controller.InitController(ginCtx)
		var idRawPtr *string = nil
		idRaw, isidExists := ginCtx.Params.Get("id")
		if isidExists {
			id := idRaw
			idRawPtr = &id
		}
		if validatorErr := validatorInstance.Var(idRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, validatorErr)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "id"
			validationError := wrapValidatorError(validatorErr, "GetUserDomicile", fieldName)
			// validation error response extension placeholder
			ginCtx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx)
			setRequestContext(ginCtx, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.GetUserDomicile(*idRawPtr)
		for key, value := range controller.GetHeaders() {
			ginCtx.Header(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx, opError)
				setRequestContext(ginCtx, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetUserDomicile'",
				Status:     statusCode,
				Instance:   "/controller/error/GetUserDomicile",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			ginCtx.JSON(statusCode, stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(ginCtx), ginCtx)
			setRequestContext(ginCtx, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		if opError == nil {
			resString := ""
			jsonValue, _ := json.Marshal(value)
			resString = string(jsonValue)
			println("Operation 'GetUserDomicile' succeeded, response: ", resString)
		}
		ginCtx.JSON(statusCode, value)
		// route end routes extension placeholder
	})
}
